---
heroImage: /src/assets/images/react-mindset.webp
category: React
description: >-
  Not everything in React needs to be a component. Over-componentization often
  creates bloated trees, unnecessary re-renders, and messy prop drilling. Learn
  when to extract components â€” and when to just keep things simple.
pubDate: 2025-09-04T20:30:00.000Z
tags:
  - performance
  - architecture
  - react
title: 'The React Anti-Component Mindset: Rethinking When and Why to Create Components'
---

# ğŸ“Œ Introduction

One of the first lessons React developers hear is:Â â€œeverything should be a component.â€Â While this sounds like a clean philosophy, taken to the extreme it causes more harm than good. This article challenges that assumption and shows why being selective with componentization can lead to simpler, faster, and more maintainable React apps.

## âš ï¸ The Pitfalls of Over-Componentization

When every tiny element is extracted into a separate component, you often face:

* Bloated component treesÂ with unnecessary nesting
* Prop drillingÂ across multiple layers
* Unwanted re-rendersÂ triggered by irrelevant updates
* Tightly coupled logicÂ thatâ€™s harder to debug
* Artificial complexityÂ without real benefit

Instead of defaulting toÂ â€œmake it a componentâ€, ask:Â â€œDoes this really need to be one?â€

## ğŸ” Rule of Thumb: Purpose Before Extraction

Before you split UI into components, consider:

* ReusabilityÂ â†’ Is it repeated across the app? Then a component makes sense.
* BehaviorÂ â†’ Does it manage its own state or effects? If yes, isolate it.
* ClarityÂ â†’ Does creating a new component reduce complexity, or just shuffle code around?

If itâ€™s just for code aesthetics, a function or inline JSX may be enough.

## ğŸ› ï¸ Functions Can Be Enough

React is still JavaScript. You donâ€™t always need a new component to avoid duplication.

Example:

```javascript
// Instead of a new <Note /> component
const renderNote = () => (
  <p className="note">Note: This action is irreversible.</p>
);

// Just call it
{ renderNote() }
```

This approach avoids unnecessary component boundaries and extra re-renders.

## ğŸ“‰ Case Study: Dropdown Item Hell

Youâ€™ve probably seen this pattern:

```javascript
<DropdownItem>
  <DropdownItemIcon />
  <DropdownItemLabel />
</DropdownItem>
```

While it looks modular, it often bloats the codebase. A flat, direct map is cleaner:

```javascript
{
  items.map(item => (
    <div className="dropdown-item" key={item.id}>
      <Icon src={item.icon} />
      <span>{item.label}</span>
    </div>
  ))
}
```

Simple, efficient, and easy to maintain.

## ğŸš« WhenÂ NotÂ to Create a Component

Skip componentization if:

* The JSX appears only once and is simple
* Youâ€™re splitting code only for â€œorganizationâ€ (use code folding instead)
* It requires passing 6+ props just to work (high coupling)
* Itâ€™s eitherÂ too dumbÂ (no logic, single-use) orÂ too smartÂ (monolithic, un-reusable)

## âœ… Focus on Composition, Not Extraction

Instead of endlessly extracting components:

* UseÂ hooksÂ to encapsulate logic
* FavorÂ compositionÂ (slots, render props, children) for flexibility
* Keep your treesÂ flat and expressive, not deeply nested

## ğŸ”‘ Conclusion

React components are powerful, but not everything belongs in one. By resisting the urge to wrap every piece of JSX into a new component, youâ€™ll end up with:

* Cleaner, flatter code
* Better performance with fewer unnecessary re-renders
* A system that scales without over-engineering
